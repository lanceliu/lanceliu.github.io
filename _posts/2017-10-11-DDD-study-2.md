---
layout: post
title:  "领域驱动设计学习笔记二-各层实现规范"
date:   2017-10-11 10:58:52
categories: ddd
published: true
comments: true
thread: 20171011101155555
---
领域驱动设计学习笔记二-各层实现规范
---

门面层 —— User Interface.门面层，对外以各种协议提供服务，该层需要明确定义支持的服务协议、契约等


应用服务层 Application Layer
    - service、assembler组成，
    - 区别于domain层的domain service，是应用服务。它是组件的粘合剂，组合domain层的各个组件和 infrastructure层的持久化组件、消息组件等等，完成具体的业务逻辑，提供完整的业务服务。
    - 通过DDD实现业务服务时，检验业务模型的质量的一个标准便是 —— service方法中不要有if/else。如果存在if/else，要么就是系统用例存在耦合，要么就是业务模型不够友好，导致部分业务逻辑泄漏到service了


领域层 Domain Layer、业务领域层，是我们最应当关心的一层，也是最多变的一层，需要保证这一层是高内聚的。确保所有的业务逻辑都留在这一层，而不会遗漏到其他层。按照ddd（domain driven design）理论，主要有如下概念构成：
    - entity
    - value object
    - domain service
    - domain event
    - factory
    - repository Interface


基础设施层 -- infrastructure 基础设施层提供公共功能组件，供controller、service、domain层调用。比如：
    - 持久化相关组件
    - httpclent
    - validation
    - exceptionHanler
    - message resource等。


层与层之间信息的传递，除了主路径代码流程外，都需要抽象出响应的业务异常。每一层尽量对下一层业务异常和本层出现的系统异常包装成本层的业务异常行为， 杜绝出现业务分支不可控的状态，对于要求比较严谨的金融领域更加适合。而且可以包含更多的信息，对于监控、和上层调用根据信息作出判断或处理。
一方面，如果使用异常替代返回错误码，错误处理代码就能从主路径代码中分离出来，得到简化
另一方面，防止导致更深层次的嵌套结构

异常回答了下面三个问题：
    - 什么出了错?
    - 在哪出的错?
    - 为什么出错?
异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪“抛出，异常信息回答了“为什么“会抛出，如果你的异常没有回答以上全部问题，那么可能你没有很好地使用它们。
有三个原则可以帮助你在调试过程中最大限度地使用好异常，这三个原则是：
    - 具体明确
    - 提早抛出
    - 延迟捕获

具体明确的异常，某些情况下多个catch块带来的额外编码工作量可能是非必要的负担，但额外的代码的确帮助程序提供了对用户更友好的响应或者是为系统的正确性提供了保证。

提早抛出异常（又称＂迅速失败＂），异常得以清晰又准确。堆栈信息立即反映出什么出了错（提供了非法参数值），为什么出错（文件名不能为空值），以及哪里出的错（readPreferences()的前部分）。通过在检测到错误时立刻抛出异常来实现迅速失败，可以有效避免不必要的对象构造或资源占用，比如文件或网络连接。同样，打开这些资源所带来的清理操作也可以省却

延迟捕获：
菜鸟和高手都可能犯的一个错是，在程序有能力处理异常之前就捕获它。Java编译器通过要求检查出的异常必须被捕获或抛出而间接助长了这种行为。自然而然的做法就是立即将代码用try块包装起来，并使用catch捕获异常，以免编译器报错。问 题在于，捕获之后该拿异常怎么办？最不该做的就是什么都不做。


[引用](http://www.importnew.com/1701.html)
